Docker 學習筆記（Module 0 → Module 7）
=====================================

本文件整理了從零開始學習 Docker 的完整心智模型，
以實際專案（API + Celery + Redis）為背景，
重點放在「理解為什麼要這樣做」，而不是死記指令。

------------------------------------------------------------
Module 0：Docker 是在解什麼問題？
------------------------------------------------------------

Docker 解決的不是「怎麼跑程式」，而是：

- 每次都能用一樣的方式跑
- 不被作業系統、環境、版本污染
- 能夠被重建、被複製、被部署

Docker 的核心價值：
- 可重複性
- 可預測性
- 環境即程式碼

Docker ≠ VM  
Docker 是「標準化的執行環境描述」。

------------------------------------------------------------
Module 1：Image、Container、Volume 的基本概念
------------------------------------------------------------

Image：
- 一個「不可變的模板」
- 包含 OS、runtime、套件、程式碼
- 不會自己執行

Container：
- Image 的一次執行實例
- 有生命週期（start / stop / remove）
- 可以被隨時銷毀

Volume：
- 用來保存「不該跟 container 一起死掉的資料」
- 將資料從 container 中分離

核心分類原則：
- Image：程式
- Container：執行
- Volume：資料

------------------------------------------------------------
Module 2：docker run 與基本執行行為
------------------------------------------------------------

docker run 本質上做了三件事：
1. 從 image 建立 container
2. 套用 runtime 設定（port、env、volume）
3. 執行指定指令

重點理解：
- Container 啟動時，只跑「一個主程式」
- 主程式結束，container 就結束

docker run 是低階工具，適合：
- 快速測試
- 理解 container 行為

------------------------------------------------------------
Module 3：Dockerfile —— 定義「這個服務是什麼」
------------------------------------------------------------

Dockerfile 用來描述 image 要怎麼 build。

常見指令與行為：

- FROM：決定基底世界
- WORKDIR：設定工作目錄
- COPY：把檔案帶進 image（會產生 layer）
- RUN：build 時執行一次的指令
- EXPOSE：文件用途，不會真的開 port
- CMD：container 啟動時的預設行為

Dockerfile 的核心觀念：
- 每一行都是一層（layer）
- layer 是不可變的
- 順序會影響 cache 與 image 大小

------------------------------------------------------------
Module 4：Image Layer、Cache 與 .dockerignore
------------------------------------------------------------

Docker build 時：
- 每個指令會產生一個 layer
- 如果指令與輸入沒變，會使用 cache

.dockerignore 的角色：
- 控制 build context
- 防止不必要的檔案進 image

必須 ignore 的典型內容：
- 虛擬環境（.venv）
- cache（__pycache__）
- 測試產物（coverage、htmlcov）
- Git 資料（.git）

重要心法：
- Dockerfile 是寫給 cache 看的
- COPY 順序錯，image 會又慢又肥

------------------------------------------------------------
Module 5：Container 如何與外界互動？
------------------------------------------------------------

Container 與外界互動有三種方式：

1. 網路（ports）
   - EXPOSE 只是說明
   - ports 才是真的打洞
   - 服務內必須 listen 0.0.0.0

2. 檔案系統（volumes）
   - Volume 會覆蓋 image 內的路徑
   - Code 應該在 image
   - Data 應該在 volume

3. 設定（env）
   - environment：寫在 compose
   - env_file：推薦方式
   - image 不應包含任何 secret

------------------------------------------------------------
Module 6：Docker 常見誤用與地雷
------------------------------------------------------------

常見錯誤：

- 把重要資料存在 container 裡
- dev 用 bind mount，prod 也照搬
- 以為 restart 能解所有問題
- 把 secret 寫進 image 或 repo
- Dockerfile 順序錯導致重 build
- 把 Docker 當 VM 用（進 container 改東西）

核心理解：
Docker 只保證「怎麼跑」，
不保證「跑得對」。

------------------------------------------------------------
Module 7：最終整合心智模型（Final）
------------------------------------------------------------

Docker 世界分三層：

1. Dockerfile（服務定義）
   - 這個服務裡有什麼？

2. Docker Compose（系統協作）
   - 這些服務怎麼一起跑？

3. Application Code（業務正確性）
   - 行為是不是對的？

問題定位順序：
1. Container 有沒有起來？
2. 服務能不能互相連線？
3. 業務邏輯是不是正確？

Dev vs Prod 判斷：
- Bind mount、.env、對外 Redis → dev
- Immutable image、named volume → prod

最終結論：

Docker 的價值不在於「跑起來一次」，
而在於「每一次都能用同樣方式跑起來」。

只要正確區分：
- 程式
- 資料
- 設定

Docker 就會變成可預期、可維護的工具。

End of notes.
